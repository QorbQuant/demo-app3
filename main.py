
"""VechainTransform.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UeY5Tsz-fggrNIunguT2a8qV1lkD9MZT
"""
import concurrent.futures
import requests
import pandas as pd
import time
from datetime import datetime
import numpy as np

import dash
from dash import html
from dash import dcc
from dash.dependencies import Input, Output, State
from dash import dash_table
import urllib.parse
import dash_bootstrap_components as dbc

# @title Pull all transactions based of address

def pull_vechain_transactions(address):
    """Pulls all VeChain transactions for a specific address"""

    API_ENDPOINT = f"https://explore.vechain.org/api/accounts/{address.lower()}/transactions"

    transactions = []

    offset = 0
    limit = 10

    # Set a flag to control the loop
    more_transactions = True

    # Loop until there are no more transactions to retrieve
    while more_transactions:
        # Set the parameters for the API request
        params = {
            "limit": limit,
            "offset": offset
        }

        # Send the request to the API endpoint
        response = requests.get(API_ENDPOINT, params=params)

        # Check the status code of the response
        if response.status_code == 200:
            # If the request was successful, get the list of transactions
            txs = response.json()['txs']

            # If the list is not empty, append the transactions to the main list
            if txs:
                transactions.extend(txs)

                # Increment the offset by the number of transactions returned
                offset += len(txs)
            else:
                # If the list is empty, there are no more transactions to retrieve
                more_transactions = False
        else:
            # If the request was not successful, print the error message and exit the loop
            print(response.text)
            more_transactions = False

    # Return the list of transactions
    # return transactions
    df = pd.DataFrame(transactions)
    # pull the timestamp

    df['blockTimestamp'] = df['meta'].apply(lambda x: x['blockTimestamp'])
    df['blockTimestamp'] = df['blockTimestamp'].apply(lambda x: datetime.fromtimestamp(x))

    return df


# @title Pull all transfers based off address
def pull_vechain_transfers(address):
    """Pulls all VeChain transfers for a specific address"""

    API_ENDPOINT = f"https://explore.vechain.org/api/accounts/{address.lower()}/transfers"

    transactions = []

    offset = 0
    limit = 10

    # Set a flag to control the loop
    more_transactions = True

    # Loop until there are no more transactions to retrieve
    while more_transactions:
        # Set the parameters for the API request
        params = {
            "limit": limit,
            "offset": offset
        }

        # Send the request to the API endpoint
        response = requests.get(API_ENDPOINT, params=params)

        # Check the status code of the response
        if response.status_code == 200:
            # If the request was successful, get the list of transactions
            txs = response.json()['transfers']

            # If the list is not empty, append the transactions to the main list
            if txs:
                transactions.extend(txs)

                # Increment the offset by the number of transactions returned
                offset += len(txs)
            else:
                # If the list is empty, there are no more transactions to retrieve
                more_transactions = False
        else:
            # If the request was not successful, print the error message and exit the loop
            print(response.text)
            more_transactions = False

    # Return the list of transactions
    # return transactions
    df = pd.DataFrame(transactions)

    df['amount'] = df['amount'].apply(lambda x: int(x, 16))
    df['amount'] = df['amount'].div(10.0 ** df['decimals'])

    df['blockTimestamp'] = df['meta'].apply(lambda x: x['blockTimestamp'])
    df['blockTimestamp'] = df['blockTimestamp'].apply(lambda x: datetime.fromtimestamp(x))

    df = df.assign(gasUsed=0)

    df = df.loc[:, ['sender', 'recipient', 'amount', 'txID', 'symbol', 'gasUsed', 'blockTimestamp']]

    return df



# @title get transaction details try

def get_transaction_details(transactions):
    """gets details and transfer info"""
    res_transfers = []
    res_receipt = []
    with concurrent.futures.ThreadPoolExecutor() as executor:
        future_to_transaction = {executor.submit(requests.get,
                                                 f'https://explore.vechain.org/api/transactions/{transaction_id}'): transaction_id
                                 for transaction_id in transactions}
        for future in concurrent.futures.as_completed(future_to_transaction):
            transaction_id = future_to_transaction[future]
            try:
                response = future.result()
                if response.status_code == 200:
                    json_response = response.json()
                    data_transfers = json_response.get('transfers', None)
                    data_receipt = [json_response['receipt']]

                    if data_transfers:
                        res_transfers.extend(data_transfers)
                    else:
                        print(f'transfers key not found in transaction_id :{transaction_id}')

                    if data_receipt:
                        res_receipt.extend(data_receipt)
                    else:
                        print(f'receipt key not found in transaction_id :{transaction_id}')

                else:
                    raise Exception(f'Error retrieving transaction details: {response.text}')

            except Exception as exc:
                print(f'Error getting transaction details for {transaction_id} generated an exception: {exc}')

            if res_transfers:
                df_transfers = pd.json_normalize(res_transfers)
            else:
                print("No data found for transfers for any transaction")
                df_transfers = pd.DataFrame()

            if res_receipt:
                df_receipt = pd.json_normalize(res_receipt)
            else:
                print("No data found for receipt for any transaction")
                df_receipt = pd.DataFrame()

            if 'txID' not in df_transfers.columns:
                raise ValueError("The 'txID' column is not present in df_transfers.")
            if 'txID' not in df_receipt.columns:
                raise ValueError("The 'txID' column is not present in df_receipt.")

            df = df_transfers.merge(df_receipt, on='txID', how='outer')

            # human readable data:
            df['amount'] = df['amount'].apply(lambda x: int(x, 16))
            df['amount'] = df['amount'].div(10.0 ** df['decimals'])
            df['gasUsed'] = df['gasUsed'] / 100000

    return df


# @title transactions complete

def transactions_complete(address):
    """ combines pulling transactions and then pulling transaction details df"""

    transactions_df = pull_vechain_transactions(address)
    tx_ids = transactions_df['txID'].tolist()

    transaction_deatails_df = get_transaction_details(tx_ids)

    merged_df = pd.merge(transaction_deatails_df, transactions_df[['txID', 'blockTimestamp']], on='txID')

    merged_df = merged_df.loc[:, ['sender', 'recipient', 'amount', 'txID', 'symbol', 'gasUsed', 'blockTimestamp']]

    return merged_df


# @title last of the raw data: combine_raw(address)
def combine_raw(address):
    """combines the transactions complete and transfers to get uniform data """

    transactions_complete_df = transactions_complete(address)
    transfers_df = pull_vechain_transfers(address)

    # Get the 'txID' column from the 'transactions_complete' DataFrame
    tx_ids = transactions_complete_df['txID']

    # Use the 'isin()' method to get a boolean mask of the rows in the 'transfers_df' DataFrame that have 'txID' values that exist in the 'tx_ids' Series
    mask = transfers_df['txID'].isin(tx_ids)

    # Use boolean indexing to remove the rows from the 'transfers_df' DataFrame that have 'txID' values that exist in the 'tx_ids' Series
    transfers_df = transfers_df[~mask]

    # Now you can concatenate the two DataFrames as before
    result_df = pd.concat([transactions_complete_df, transfers_df])

    return result_df



# @title make bitwave compatable
def bitwave_compat(address):
    df = combine_raw(address)
    wallet = address

    # reformat
    df['amount'] = pd.to_numeric(df['amount'])
    df['gasUsed'] = pd.to_numeric(df['gasUsed'])
    df = df.assign(feeTicker='VTHO')

    df['blockTimestamp'] = pd.to_datetime(df['blockTimestamp'])
    df = df.sort_values(by='blockTimestamp')
    df = df.reset_index(drop=True)

    df = df[(df['sender'] != wallet) & (df['recipient'] != wallet)]

    # establish deposits/withdrawals
    df.loc[:, 'transactionType'] = np.where(
        df.loc[:, 'recipient'] == wallet.lower(),  # if from wallet
        'deposit',  # if condition is met
        'withdrawal'  # if condition is not met
    )

    # remove wallet from self
    # vecahin_wallets.remove(wallet)
    # establish if taxable or not
    df['taxExempt'] = 'FALSE'

    id = 'test'  # build into function later

    # create transaction ID column
    df = df.assign(id=f'{id}')
    df['rownum'] = np.arange(df.shape[0])
    df['id'] = df['id'] + df['rownum'].astype(str)
    df.drop('rownum', axis=1, inplace=True)

    # make fee 0 if deposit
    df.loc[df['transactionType'] == 'deposit', 'gasUsed'] = 0

    accountid = 'test'  # build into function later

    # add necessary columns
    df = df.assign(cost='')
    df = df.assign(costTicker='')
    df = df.assign(memo='')  # might turn into a f string variable
    df = df.assign(accountId=f'{accountid}')  # account id is wallet id from BitWave
    df = df.assign(contactId='')
    df = df.assign(categoryId='')
    df = df.assign(remoteContactId='')

    # rename
    df.rename(columns={'txID': 'blockchainId', 'blockTimestamp': 'time', 'symbol': 'amountTicker', 'gasUsed': 'fee', },
              inplace=True)

    # reorder
    df = df[['id', 'remoteContactId', 'amount', 'amountTicker', 'cost', 'costTicker', 'fee', 'feeTicker', 'time',
             'blockchainId', 'memo', 'transactionType', 'accountId', 'contactId', 'categoryId', 'taxExempt']]

    return df



"""
app = jupyter_dash.JupyterDash(__name__)
"""
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])


def generate_table(dataframe, style_table={'overflowX': 'scroll'}):
    print(dataframe.columns)
    return dash_table.DataTable(
        id='datatable-interactivity',
        columns=[{"name": i, "id": i} for i in dataframe.columns],
        data=dataframe.to_dict("rows"),
        export_format='csv',
        export_headers='display',
    )


"""
app.layout = html.Div([
    html.H1('VeChain X Bitwave'),
    html.H2('Submit your VeChainThor Address'),
    dcc.Input(id='address', placeholder='0x85C49B8B63Aa66f32C9909937095868A399cE6Aa'),
    html.Button('Submit', id='button'),
    html.Div(id='output'),
    html.A(id='download-link', children='Download CSV'),
])
"""
app.layout = html.Div([
    dcc.Loading(id='loading', children=[
        dbc.Container(
            [
                dbc.Row(
                    [
                        dbc.Col(
                            dbc.Card(
                                [
                                    dbc.CardHeader(
                                        html.H1("VeChain X Bitwave", className="text-center")
                                    ),
                                    dbc.CardBody(
                                        [
                                            html.P(
                                                "Submit your VeChainThor Address", className="text-center"
                                            ),
                                            dbc.Row(
                                                [
                                                    dbc.Col(
                                                        dbc.Input(id='address',
                                                                  placeholder='0x85C49B8B63Aa66f32C9909937095868A399cE6Aa',
                                                                  type='text'),
                                                        width={"size": 6, "offset": 3},
                                                    ),
                                                ]
                                            ),
                                            html.Br(),
                                            html.Div(id='output'),
                                            dbc.Row(
                                                [
                                                    dbc.Col(
                                                        html.Button('Submit', id='button', n_clicks=0,
                                                                    className='btn btn-primary btn-block'),
                                                        width={"size": 6, "offset": 3},
                                                    ),
                                                ]
                                            ),
                                            html.Br(),
                                            dbc.Row(
                                                [
                                                    dbc.Col(
                                                        html.A(id='download-link', children='Download CSV',
                                                               className='btn btn-secondary btn-block'),
                                                        width={"size": 6, "offset": 3},
                                                    ),
                                                ]
                                            ),
                                        ]
                                    )
                                ],
                                className="bg-light"
                            ),
                            width={"size": 12, "offset": 0},
                        ),
                    ]
                ),
            ],
            fluid=True,
        )
    ], type='circle'),
    html.Div(id='loading-output', style={'display': 'none'}),
    dbc.Button('Submit', id='load-data-button', n_clicks=0)
])


@app.callback(
    Output(component_id='output', component_property='children'),
    [Input(component_id='button', component_property='n_clicks')],
    [State(component_id='address', component_property='value')])
def update_output(n_clicks, address):
    data = bitwave_compat(address)
    print(data)
    return html.Div([
        html.H2('Data for address: {}'.format(address)),
        generate_table(data)
    ])


@app.callback(
    Output('download-link', 'href'),
    [Input('button', 'n_clicks')],
    [State(component_id='address', component_property='value')])
def update_download_link(n_clicks, address):
    if n_clicks:
        data = bitwave_compat(address)
        df = pd.DataFrame(data)
        csv_string = df.to_csv(index=False, encoding='utf-8', line_terminator='\n')
        csv_string = "data:text/csv;charset=utf-8," + urllib.parse.quote(csv_string)
        return csv_string


@app.callback(
    Output('download-link', 'download'),
    [Input('datatable-interactivity', 'data')])
def update_download_name(data):
    return 'data.csv'


# Define the callback for the DataTable component
@app.callback(
    Output(component_id='datatable-interactivity', component_property='style_data_conditional'),
    [Input(component_id='datatable-interactivity', component_property='data')])
def update_table_style(rows):
    return [
        {
            'if': {'row_index': 'odd'},
            'backgroundColor': 'rgb(248, 248, 248)',
        },
        {
            'if': {'column_id': 'column_name'},
            'backgroundColor': '#3D9970',
            'color': 'white',
        },
        {
            'if': {'column_id': 'other_column_name'},
            'backgroundColor': '#FF4136',
            'color': 'white',
        }
    ]


@app.callback(
    Output(component_id='datatable-interactivity', component_property='style_cell'),
    [Input(component_id='datatable-interactivity', component_property='columns')])
def update_cell_style(columns):
    return {
        'fontWeight': 'bold',
        'textAlign': 'center'
    }


if __name__ == '__main__':
    app.run_server(debug=False)

